import java.util.*;
import java.util.Map;

public class Utility {

    /**
     * Calculate the Euclidean distance between two VRP nodes
     * @param node1 the first VRP node
     * @param node2 the second VRP node
     * @return the Euclidean distance between node1 and node2
     */
    public static double calculateEuclideanDistance(VRPNode node1, VRPNode node2) {
        // TODO: Implement the function to calculate the Euclidean distance.
        double x_dif_squared = Math.pow(node1.getX() - node2.getX(),2);
        double y_dif_squared = Math.pow(node1.getY() - node2.getY(),2);

        return Math.sqrt(x_dif_squared + y_dif_squared);
    }

    /**
     * Calculate the total cost of a VRP solution under a VRP instance.
     * The total cost is the sum of all the Euclidean distance between adjacent nodes in the routes.
     * @param solution the VRP solution.
     * @param instance the VRP instance.
     * @return the total cost of the solution.
     */
    public static double calculateTotalCost(VRPSolution solution, VRPInstance instance) {
        // TODO: Implement the function to calculate the total cost of the solution.
        double total_cost = 0.0;

        Map<Integer, VRPNode> nodes = instance.getNodes();
        List<List<Integer>> routes = solution.getRoutes();

        for(List<Integer> route: routes){

            // distance from depot to the first node
            VRPNode depot = instance.getDepot();
            VRPNode first_node = nodes.get(route.get(0));
            total_cost = total_cost + calculateEuclideanDistance(depot, first_node);

            for(int i=1; i<route.size()-1; i++){

                VRPNode node1 = nodes.get(route.get(i));
                VRPNode node2 = nodes.get(route.get(i+1));
                total_cost = total_cost + calculateEuclideanDistance(node1, node2);

            }

            // distance from last node to the depot
            VRPNode last_node = nodes.get(route.get(route.size()-1));
            total_cost = total_cost + calculateEuclideanDistance(depot, last_node);

        }

        return total_cost;
    }

    /**
     * Generate a VRP solution for a VRP instance using the nearest neighbour heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the nearest neighbour heuristic.
     */
    public static VRPSolution nearestNeighbourHeuristic(VRPInstance instance) {

        int total_nodes = instance.getNodes().size();
        List<List<Integer>> routes = new ArrayList<>();
        Map<Integer, VRPNode> nodes = new HashMap<>();

        // changing the id of all the nodes to start from 0.
        for(Map.Entry<Integer, VRPNode> entry: instance.getNodes().entrySet()){
            nodes.put(entry.getKey()-1, entry.getValue());
        }

//        for(Map.Entry<Integer, VRPNode> entry: nodes.entrySet()){
//            System.out.print(entry.getKey() + " ");
//            System.out.println(entry.getValue().toString());
//        }

        // ----------------------Calculate the all distances between all pair of nodes.---------------------------------

        double[][] distance_matrix = new double[total_nodes][total_nodes];
        for(int row=0; row<total_nodes; row++){

            VRPNode from_node = nodes.get(row);

            for(int col=0; col<total_nodes; col++){

                VRPNode to_node = nodes.get(col);
                distance_matrix[row][col] = calculateEuclideanDistance(from_node, to_node);

            }

        }
        String header = "\t";
        for(int i=1; i<33; i++){
            header = header + i + "\t\t";
        }
        System.out.print(header +"\n");
        for(int row=0; row<total_nodes; row++){
            System.out.print((row+1) + "\t");
            for(int col=0; col<total_nodes; col++){
                if(distance_matrix[row][col] == 0.0){
                    System.out.print("0.0");
                    System.out.print("\t\t");
                }
                else if(distance_matrix[row][col] < 10.0){
                    System.out.print(Math.round(distance_matrix[row][col] * 10.0) / 10.0);
                    System.out.print("\t\t");
                }
                else {
                    double a = Math.round(distance_matrix[row][col] * 10.0) / 10.0;
                    System.out.print(a);
                    System.out.print("\t");
                }
            }
            System.out.println("");
        }

        // -------------------------------------------------------------------------------------------------------------


        // ----------------------Start finding routes-------------------------------------------------------------------

        HashSet<Integer> visited_id = new HashSet<>();
        visited_id.add(0);

        while(visited_id.size() < total_nodes){

            List<Integer> route = new ArrayList<>();
            double capacity = instance.getCapacity();

            // -----------------------find the node that is closest to the depot----------------------------------------
            double min_distance = 1000;
            int current_id = -1;

            // skipping col=0 as it will be depot to depot, from 1 means from the first neighbour node.
            for(int col=1; col<total_nodes; col++){

                if(!visited_id.contains(col) && distance_matrix[0][col] < min_distance){
                    min_distance = distance_matrix[0][col];
                    current_id = col;
                }

            }

            // add the node closest to depot into the route
            route.add(current_id);
            visited_id.add(current_id);
            capacity = capacity - nodes.get(current_id).getDemand();

            // ---------------------------------------------------------------------------------------------------------

            // ------------------keep expanding the nodes (find the closest to this node)-------------------------------
            while(true){

                int next_id = -1;
                double min_dist = 1000;

                // finding the closest neighbour to the current neighbour, skipping 1 as we don't want to count the
                // path back to depot.
                for(int col=1; col<total_nodes; col++) {

                    // if the neighbour is not visited and distance is smaller than current min
                    if(!visited_id.contains(col) && distance_matrix[current_id][col] < min_dist && col != current_id){

                        double node_demand = nodes.get(col).getDemand();

                        // if the demand of the node doesn't go over the capacity
                        if(capacity - node_demand >= 0){

                            min_dist = distance_matrix[current_id][col];
                            next_id = col;

                        }

                    }

                }

                // if next_id == -1 means all other nodes exceed capacity, return back to depot
                if(next_id == -1){
                    break;
                }
                else{
                    // found the next node, add to the route and mark it as visited.
                    route.add(next_id);
                    visited_id.add(next_id);
                    capacity = capacity - nodes.get(next_id).getDemand();
                    current_id = next_id;
                }

                if(capacity == 0){
                    break;
                }

            }

            routes.add(route);

        }
        // -------------------------------------------------------------------------------------------------------------

        for(List<Integer> route: routes){
            for(int i=0; i<route.size(); i++){
                route.set(i, route.get(i)+1);
            }
            System.out.println(route);
        }

        return new VRPSolution(routes);
    }

    /**
     * Generate a VRP solution for a VRP instance using the savings heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the savings heuristic.
     */
    public static VRPSolution savingsHeuristic(VRPInstance instance) {
        // TODO: Implement the savings heuristic.
        return null;
    }

}





//        // ---------------------Putting all the distances into sorted maps.---------------------------------------------
//
//        // index of each tree map represents the id of a node.
//        List<TreeMap<Double, Integer>> sorted_maps = new ArrayList<>();  //TreeMap<distance, id>
//
//        // first item is null so that second item with index 1 can represent the first node.
//        sorted_maps.add(null);
//
//        for(int row=0; row<total_nodes; row++){
//
//            TreeMap<Double, Integer> tree_map = new TreeMap<>();
//
//            for(int col=0; col<total_nodes; col++){
//
//                if(tree_map.keySet().contains(distance_matrix[row][col])){
//                    System.out.println("already exists");
//                }
//                tree_map.put(distance_matrix[row][col], col+1);
//
//            }
//
//            sorted_maps.add(tree_map);
//
//        }
//
//        // -------------------------------------------------------------------------------------------------------------