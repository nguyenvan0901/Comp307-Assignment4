import java.util.*;
import java.util.Map;

public class Utility {

    /**
     * Calculate the Euclidean distance between two VRP nodes
     * @param node1 the first VRP node
     * @param node2 the second VRP node
     * @return the Euclidean distance between node1 and node2
     */
    public static double calculateEuclideanDistance(VRPNode node1, VRPNode node2) {
        // TODO: Implement the function to calculate the Euclidean distance.
        double x_dif_squared = Math.pow(node1.getX() - node2.getX(),2);
        double y_dif_squared = Math.pow(node1.getY() - node2.getY(),2);

        return Math.sqrt(x_dif_squared + y_dif_squared);
    }

    /**
     * Calculate the total cost of a VRP solution under a VRP instance.
     * The total cost is the sum of all the Euclidean distance between adjacent nodes in the routes.
     * @param solution the VRP solution.
     * @param instance the VRP instance.
     * @return the total cost of the solution.
     */
    public static double calculateTotalCost(VRPSolution solution, VRPInstance instance) {
        // TODO: Implement the function to calculate the total cost of the solution.
        double total_cost = 0.0;

        Map<Integer, VRPNode> nodes = instance.getNodes();
        List<List<Integer>> routes = solution.getRoutes();

        for(List<Integer> route: routes){

            // distance from depot to the first node
            VRPNode depot = instance.getDepot();
            VRPNode first_node = nodes.get(route.get(0));
            total_cost = total_cost + calculateEuclideanDistance(depot, first_node);

            for(int i=1; i<route.size()-1; i++){

                VRPNode node1 = nodes.get(route.get(i));
                VRPNode node2 = nodes.get(route.get(i+1));
                total_cost = total_cost + calculateEuclideanDistance(node1, node2);

            }

            // distance from last node to the depot
            VRPNode last_node = nodes.get(route.get(route.size()-1));
            total_cost = total_cost + calculateEuclideanDistance(depot, last_node);

        }

        return total_cost;
    }

    /**
     * Generate a VRP solution for a VRP instance using the nearest neighbour heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the nearest neighbour heuristic.
     */
    public static VRPSolution nearestNeighbourHeuristic(VRPInstance instance) {
        System.out.println("Depot: " + instance.getDepot().toString());

        int total_nodes = instance.getNodes().size();
        List<List<Integer>> routes = new ArrayList<>();

        // ----------------------Calculate the all distances between all pair of nodes.------------------------------

        double[][] distance_matrix = new double[total_nodes][total_nodes];

        for(int row=0; row<total_nodes; row++){

            VRPNode from_node = instance.getNodes().get(row+1);

            for(int col=0; col<total_nodes; col++){

                VRPNode to_node = instance.getNodes().get(col+1);
                distance_matrix[row][col] = calculateEuclideanDistance(from_node, to_node);

            }

        }
        // -------------------------------------------------------------------------------------------------------------


        // ----------------------Start finding routes-------------------------------------------------------------------

        HashSet<Integer> visited_id = new HashSet<>();

        while(visited_id.size()-1 < total_nodes){

            List<Integer> route = new ArrayList<>();

            // find the node closest to depot
            int depot_row = 0;
            double capacity = instance.getCapacity();

            // id = -1 shouldn't happen
            int id = -1;
            double min_dist = 100000;

            // starting from 1 so it doesn't count the route to depot
            for(int col=1; col<total_nodes; col++){

                if(!visited_id.contains(col+1)) {

                    if (distance_matrix[depot_row][col] < min_dist) {

                        id = col + 1;
                        min_dist = distance_matrix[depot_row][col];

                    }

                }

            }

            // add the closest node to the depot to the route
            visited_id.add(id);
            route.add(id);
            capacity = capacity - instance.getNodes().get(id).getDemand();

            // keep expend the route from here! (find next closet node)
            while(true){

                double min_dist2 = 10000;
                // ide2 = -1 will only happen if no other node is suitable, then return back to depot.
                int id2 = -1;
                int row = id-1;

                for(int col=1; col<total_nodes; col++){

                    if(!visited_id.contains(col+1)){

                        if(capacity - instance.getNodes().get(col+1).getDemand() > 0){

                            if(distance_matrix[row][col] != 0 && distance_matrix[row][col] < min_dist2){



                            }

                        }

                    }
                }

            }






        }





        // -------------------------------------------------------------------------------------------------------------



        return new VRPSolution(routes);
    }

    /**
     * Generate a VRP solution for a VRP instance using the savings heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the savings heuristic.
     */
    public static VRPSolution savingsHeuristic(VRPInstance instance) {
        // TODO: Implement the savings heuristic.
        return null;
    }

}





//        // ---------------------Putting all the distances into sorted maps.---------------------------------------------
//
//        // index of each tree map represents the id of a node.
//        List<TreeMap<Double, Integer>> sorted_maps = new ArrayList<>();  //TreeMap<distance, id>
//
//        // first item is null so that second item with index 1 can represent the first node.
//        sorted_maps.add(null);
//
//        for(int row=0; row<total_nodes; row++){
//
//            TreeMap<Double, Integer> tree_map = new TreeMap<>();
//
//            for(int col=0; col<total_nodes; col++){
//
//                if(tree_map.keySet().contains(distance_matrix[row][col])){
//                    System.out.println("already exists");
//                }
//                tree_map.put(distance_matrix[row][col], col+1);
//
//            }
//
//            sorted_maps.add(tree_map);
//
//        }
//
//        // -------------------------------------------------------------------------------------------------------------