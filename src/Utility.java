import java.util.*;
import java.util.Map;

public class Utility {

    /**
     * Calculate the Euclidean distance between two VRP nodes
     * @param node1 the first VRP node
     * @param node2 the second VRP node
     * @return the Euclidean distance between node1 and node2
     */
    public static double calculateEuclideanDistance(VRPNode node1, VRPNode node2) {
        // TODO: Implement the function to calculate the Euclidean distance.
        double x_dif_squared = Math.pow(node1.getX() - node2.getX(),2);
        double y_dif_squared = Math.pow(node1.getY() - node2.getY(),2);

        return Math.sqrt(x_dif_squared + y_dif_squared);
    }

    /**
     * Calculate the total cost of a VRP solution under a VRP instance.
     * The total cost is the sum of all the Euclidean distance between adjacent nodes in the routes.
     * @param solution the VRP solution.
     * @param instance the VRP instance.
     * @return the total cost of the solution.
     */
    public static double calculateTotalCost(VRPSolution solution, VRPInstance instance) {
        // TODO: Implement the function to calculate the total cost of the solution.

        double total_cost = 0.0;

        Map<Integer, VRPNode> nodes = instance.getNodes();
        List<List<Integer>> routes = solution.getRoutes();

        for(List<Integer> route: routes){

            // distance from depot to the first node
            VRPNode depot = instance.getDepot();
            VRPNode first_node = nodes.get(route.get(0));
            total_cost = total_cost + calculateEuclideanDistance(depot, first_node);

            for(int i=0; i<route.size()-1; i++){

                VRPNode node1 = nodes.get(route.get(i));
                VRPNode node2 = nodes.get(route.get(i+1));
                total_cost = total_cost + calculateEuclideanDistance(node1, node2);

            }

            // distance from last node to the depot
            VRPNode last_node = nodes.get(route.get(route.size()-1));
            total_cost = total_cost + calculateEuclideanDistance(depot, last_node);

        }

        return total_cost;
    }

    /**
     * Generate a VRP solution for a VRP instance using the nearest neighbour heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the nearest neighbour heuristic.
     */
    public static VRPSolution nearestNeighbourHeuristic(VRPInstance instance) {

        int total_nodes = instance.getNodes().size();
        List<List<Integer>> routes = new ArrayList<>();
        Map<Integer, VRPNode> nodes = new HashMap<>();

        // changing the id of all the nodes to start from 0.
        for(Map.Entry<Integer, VRPNode> entry: instance.getNodes().entrySet()){
            nodes.put(entry.getKey()-1, entry.getValue());
        }

        // ----------------------Calculate the all distances between all pair of nodes.---------------------------------

        double[][] distance_matrix = calculateDistanceMatrix(nodes);

        String header = "\t";
        for(int i=0; i<32; i++){
            header = header + i + "\t\t";
        }
        System.out.print(header +"\n");
        for(int row=0; row<total_nodes; row++){
            System.out.print((row) + "\t");
            for(int col=0; col<total_nodes; col++){
                if(distance_matrix[row][col] == 0.0){
                    System.out.print("0.0");
                    System.out.print("\t\t");
                }
                else if(distance_matrix[row][col] < 10.0){
                    System.out.print(Math.round(distance_matrix[row][col] * 10.0) / 10.0);
                    System.out.print("\t\t");
                }
                else {
                    double a = Math.round(distance_matrix[row][col] * 10.0) / 10.0;
                    System.out.print(a);
                    System.out.print("\t");
                }
            }
            System.out.println("");
        }

        // -------------------------------------------------------------------------------------------------------------


        // ----------------------Start finding routes-------------------------------------------------------------------

        HashSet<Integer> visited_id = new HashSet<>();
        visited_id.add(0);

        while(visited_id.size() < total_nodes){

            List<Integer> route = new ArrayList<>();
            double capacity = instance.getCapacity();

            // -----------------------find the node that is closest to the depot----------------------------------------
            double min_distance = 1000;
            int depot_row = 0;
            int current_id = -1;

            // skipping col=0 as it will be depot to depot, from 1 means from the first neighbour node.
            for(int col=1; col<total_nodes; col++){

                if(!visited_id.contains(col) && distance_matrix[depot_row][col] < min_distance){
                    min_distance = distance_matrix[depot_row][col];
                    current_id = col;
                }

            }

            // add the node closest to depot into the route
            route.add(current_id);
            visited_id.add(current_id);
            capacity = capacity - nodes.get(current_id).getDemand();

            // ---------------------------------------------------------------------------------------------------------

            // ------------------keep expanding the nodes (find the closest to this node)-------------------------------
            while(true){

                int next_id = -1;
                double min_dist = 1000;

                // finding the closest neighbour to the current neighbour, skipping 0 as we don't want to count the
                // path back to depot.
                for(int col=1; col<total_nodes; col++) {

                    // if the neighbour is not visited and distance is smaller than current min
                    if(!visited_id.contains(col) && distance_matrix[current_id][col] < min_dist && col != current_id){

                        double node_demand = nodes.get(col).getDemand();

                        // if the demand of the node doesn't go over the capacity
                        if(capacity - node_demand >= 0){

                            min_dist = distance_matrix[current_id][col];
                            next_id = col;

                        }

                    }

                }

                // if next_id == -1 means all other nodes exceed capacity, return to depot
                if(next_id == -1){
                    break;
                }
                else{
                    // found the next node, add to the route and mark it as visited.
                    route.add(next_id);
                    visited_id.add(next_id);
                    capacity = capacity - nodes.get(next_id).getDemand();
                    current_id = next_id;
                }

                if(capacity == 0){ // route can't fit any more node, exit loop and create a new route.
                    break;
                }

            }

            routes.add(route);

        }
        // -------------------------------------------------------------------------------------------------------------

        for(List<Integer> route: routes){
            for(int i=0; i<route.size(); i++){
                route.set(i, route.get(i)+1);
            }
            System.out.println(route);
        }

        return new VRPSolution(routes);
    }

    /**
     * Generate a VRP solution for a VRP instance using the savings heuristic.
     * @param instance the VRP instance.
     * @return the VRP solution generated by the savings heuristic.
     */
    public static VRPSolution savingsHeuristic(VRPInstance instance) {
        // TODO: Implement the savings heuristic.

        int total_nodes = instance.getNodes().size();
        List<List<Integer>> routes = new ArrayList<>();
        Map<Integer, VRPNode> nodes_map = new HashMap<>();
        double capacity = instance.getCapacity();

        // changing the id of all the nodes to start from 0.
        for(Map.Entry<Integer, VRPNode> entry: instance.getNodes().entrySet()){
            nodes_map.put(entry.getKey()-1, entry.getValue());
            nodes_map.get(entry.getKey()-1).setID();
        }


        // ----------------------Calculate the all distances between all pair of nodes.---------------------------------
        double[][] distance_matrix = calculateDistanceMatrix(nodes_map);
        // -------------------------------------------------------------------------------------------------------------

        // ----------------------Creating initial routes----------------------------------------------------------------
        List<Route> initial_routes = new ArrayList<>();

        for(int i=1; i<total_nodes; i++){
            initial_routes.add(new Route(nodes_map.get(i)));
        }

        // -------------------------------------------------------------------------------------------------------------

        // ----------------------Creating merges between 2 nodes.-------------------------------------------------------

        Queue<Merge> merge_queue = new PriorityQueue<>();
        List<Merge> merge_list = new ArrayList<>();

        for(int i=0; i<initial_routes.size(); i++){

            Route r1 = initial_routes.get(i);

            for(int j=0; j<initial_routes.size(); j++){

                if(j != i) {
                    Route r2 = initial_routes.get(j);
                    int tail_r1 = r1.getTailID();
                    int head_r2 = r2.getHeadId();

                    // saving = l(v1,depot) + l(v2,depot) - l(v1,v2)
                    double saving = distance_matrix[0][tail_r1] + distance_matrix[0][head_r2]
                                  - distance_matrix[tail_r1][head_r2];

                    Merge merge = new Merge(r1, r2, saving);
                    merge_queue.add(merge);
                    merge_list.add(merge);
                }

            }

        }

        Collections.sort(merge_list);
        for(int i=0; i<100; i++){
            System.out.println(merge_list.get(i).toString());
        }
        System.out.println("end testing for list \n");

        for(int i=0; i<100; i++){
            System.out.println(merge_queue.poll().toString());
        }

        // -------------------------------------------------------------------------------------------------------------

        // ----------------------Continue merging until no merge can be made.-------------------------------------------
        for(int i=0; i<100; i++){
            System.out.println(merge_queue.poll().toString());
        }

//        while(true){
//
//            boolean found_a_merge = false;
//
//            // this will be the merge with the highest saving.
//            Merge merge = merge_queue.poll();
//            Route route1 = merge.getRoute1();
//            Route route2 = merge.getRoute2();
//
//            // if 2 routes' demand combined is still less than capacity, join them.
//            if(route1.getDemand() + route2.getDemand() <= capacity){
//
//                found_a_merge = true;
//
//                // update demand of route 1
//                route1.updateDemand(route2.getDemand());
//
//                // add all nodes on route 2 into route 1
//                List<Integer> node_ids = route2.getNodes();
//                for(Integer i: node_ids){
//                    route1.addToRoute(i);
//                }
//
//                // delete all merges from route 1 to anywhere else and also delete merge from route 2 back to route 1.
//                for(int i=0; i<merge_queue.size(); i++){
//
//                    Merge m = merge_queue.get
//
//                }
//
//                // create new merge from the new route to all other route.
//
//            }
//
//            if(found_a_merge){
//                break;
//            }
//
//        }
        // -------------------------------------------------------------------------------------------------------------


        return new VRPSolution(routes);
    }

    public static double[][] calculateDistanceMatrix(Map<Integer, VRPNode> nodes){

        int total_nodes = nodes.size();
        double[][] distance_matrix = new double[total_nodes][total_nodes];

        for(int row=0; row<total_nodes; row++){

            VRPNode from_node = nodes.get(row);

            for(int col=0; col<total_nodes; col++){

                VRPNode to_node = nodes.get(col);
                distance_matrix[row][col] = calculateEuclideanDistance(from_node, to_node);

            }

        }

        return distance_matrix;
    }

}
